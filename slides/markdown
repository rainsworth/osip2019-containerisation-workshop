class: left, middle
# Reproducible Research through Containerisation:
##  Docker and Singularity
<br><br>
[Open Science In Practice](http://osip2019.epfl.ch/)  
EPFL, Lausanne, Switzerland  
11:00-13:00, 5 September 2019  
<br><br>
Speaker: Dr. Rachael Ainsworth, University of Manchester  
Twitter: [@rachaelevelyn](https://twitter.com/rachaelevelyn), GitHub: [@rainsworth](https://github.com/rainsworth/)
---
layout: true
class: content
---
class: left, middle
# Acknowledgements

Resources used to develop this workshop:
* _The Turing Way_: [GitHub](https://github.com/alan-turing-institute/the-turing-way), [Book](https://the-turing-way.netlify.com), [Zenodo](http://doi.org/10.5281/zenodo.3233986)
* [Melbourne Bioinformatics' Containerized Bioinformatics tutorial](https://www.melbournebioinformatics.org.au/tutorials/tutorials/docker/docker/)
* [Getting started with Docker](https://docs.docker.com/get-started/)
---
class: left, middle
# Dr. Rachael Ainsworth

* Research Associate & Open Science Champion, University of Manchester
* Software Sustainability Institute Fellow
* FOSTER Open Science Trainer
* Mozilla Open Leader (Round 4 Project Lead, Round 5 Mentor & Cohort Host)
* _The Turing Way_ Core Contributor
* HER+Data MCR Organiser
* Likes meeting new people, learning new things, coffee & travelling.
* Twitter: [@rachaelevelyn](https://twitter.com/rachaelevelyn)  
* GitHub: [@rainsworth](https://github.com/rainsworth/)

---
class: left, middle
# Agenda

1. Learning objectives
2. Feedback practice: Software Carpentry style traffic lights
3. Introduction to Reproducibility through Containerisation
4. Exercise: Hello world!
5. Comfort break
6. Exercise: Run an application in an existing container
7. Exercise: Build your own container
8. Exercise: Upload your container to DockerHub
9. Summary and closing

---
class: center, middle
# Learning Objectives
---
class: left, middle
# Learning Objectives

After the workshop, participants should know:
* What containerisation is and why they might use it in their research.
* Some common containerisation tools and when to use them.
* How to find and run containers built by other people.
* How to build their own container.
* How to distribute their container online.
---
class: center, middle
# Part 0
## Feedback practice: Software Carpentry style traffic lights
---
class: left, middle
# Feedback practice: traffic lights

Indicate how much you agree with the follow statements using Software Carpentry style traffic lights.

.center[
#### I feel fully caffeinated this morning.
]

.columns[
  .column[.center[Agree]
    ![](assets/postit-green.png)
  ]
  .column[.center[Disagree]
    ![](assets/postit-red.png)
  ]
]

.center[Attribution: Alex Morley http://doi.org/10.5281/zenodo.2598522]
---
# Feedback practice: traffic lights

Indicate how much you agree with the follow statements using Software Carpentry style traffic lights.

.center[
#### Today I am using: Linux (any flavour).
]

.columns[
  .column[.center[Agree]
    ![](assets/postit-green.png)
  ]
  .column[.center[Disagree]
    ![](assets/postit-red.png)
  ]
]

.center[Attribution: Alex Morley http://doi.org/10.5281/zenodo.2598522]
---
# Feedback practice: traffic lights

Indicate how much you agree with the follow statements using Software Carpentry style traffic lights.

.center[
#### Today I am using: Mac (OSX).
]

.columns[
  .column[.center[Agree]
    ![](assets/postit-green.png)
  ]
  .column[.center[Disagree]
    ![](assets/postit-red.png)
  ]
]

.center[Attribution: Alex Morley http://doi.org/10.5281/zenodo.2598522]
---
# Feedback practice: traffic lights

Indicate how much you agree with the follow statements using Software Carpentry style traffic lights.

.center[
#### Today I am using: Windows.
]

.columns[
  .column[.center[Agree]
    ![](assets/postit-green.png)
  ]
  .column[.center[Disagree]
    ![](assets/postit-red.png)
  ]
]

.center[Attribution: Alex Morley http://doi.org/10.5281/zenodo.2598522]
---
# Feedback practice: traffic lights

Indicate how much you agree with the follow statements using Software Carpentry style traffic lights.

.center[
#### I have installed Docker.
]

.columns[
  .column[.center[Agree]
    ![](assets/postit-green.png)
  ]
  .column[.center[Disagree]
    ![](assets/postit-red.png)
  ]
]

.center[Attribution: Alex Morley http://doi.org/10.5281/zenodo.2598522]
---
# Feedback practice: traffic lights

Indicate how much you agree with the follow statements using Software Carpentry style traffic lights.

.center[
#### I have some previous experience using containers.
]

.columns[
  .column[.center[Agree]
    ![](assets/postit-green.png)
  ]
  .column[.center[Disagree]
    ![](assets/postit-red.png)
  ]
]

.center[Attribution: Alex Morley http://doi.org/10.5281/zenodo.2598522]
---
class: center, middle
# Part 1
## Introduction to Reproducibility through Containerisation
---
# Reproducibility

.img-med[
![](assets/1728_TURI_Book sprint_39 reproducible replicable robust generalisable_040619.jpg)
]

.center[Attribution: The Turing Way Community & Scriberia, http://doi.org/10.5281/zenodo.3332808]
---
# Reproducibility Spectrum

.img-med[
![](assets/ReproducibilitySpectrum.jpg)
]

> Computational science has led to exciting new developments, but the nature of the work has exposed limitations in our ability to evaluate published findings. Reproducibility has the potential to serve as a minimum standard for judging scientific claims when full independent replication of a study is not possible.”  

>(Peng 2011; https://doi.org/10.1126/science.1213847)

---
class: center, middle
# "But it worked on my laptop..."
---
# Reproducible Environments: Importance

Simple Python script example:

```
a = 1
b = 5
print(a/b)
```

--

* Output of 1 divided by 5 in Python 3: `0.2`

--

* Output of 1 divided by 5 in Python 2: `0`

--

* This is because integer division is applied to integers in Python 2, but (normal) division is applied to all types, including integers, in Python 3.  

--

* This very simple script returns _different_ answers depending on the computational environment in which it is run. 
* Using the wrong version of Python is easy to do, and demonstrates how a perfectly valid piece of code can give different results depending on its environment. 
* If such issues can impact a simple script like this, imagine how many could appear in a complex analysis procedure which may involve thousands of lines of code and dozens of dependent packages!

.center[Attribution: [The Turing Way](https://the-turing-way.netlify.com/reproducible_environments/01/options.html)]
---
# Reproducible Environments: Impact

It is vital for researchers to understand and capture the computational environments in which they are conducting their work, as it has the potential to impact:

* **You**: Your working environment evolves over time as you update software, install new software and move to different computers. If the project environment is not captured and you need to return to that project after months or years (as is common in research), you may have no way of knowing what changes to the environment have occurred. This will impact your ability to run the code and on the results.

--

* **Your collaborators**: Research is collaborative, and conducting research in multiple different computational environments opens up a minefield of potential bugs. Trying to fix these kinds of issues is often time consuming and frustrating as researchers have to figure out what the differences between computational environments are and their effects. Worse, some bugs may remain undetected, potentially impacting the results.

--

* **Science**: How research is conducted has evolved significantly over the past decade, but the same cannot be said for the methods by which research processes are captured and disseminated. Research articles alone are no longer sufficient to verify, reproduce and extend scientific results. For research to be reproducible, researchers must publish and distribute the entire contained analysis, not just its results. Any research that is limited to where it can be deployed is instantly limited in the extent that it can be reproduced.

.center[Attribution: [The Turing Way](https://the-turing-way.netlify.com/reproducible_environments/01/options.html)]
---
# Reproducible Environments: Options

.img-med[
![](assets/ReproducibleEnvironments.png)
]

.center[Attribution: [The Turing Way](https://the-turing-way.netlify.com/reproducible_environments/01/options.html)]
---
# Virtual Machines (VMs) vs Containers

* A **virtual machine (VM)** is a program that emulates a complete computer and imitates dedicated hardware. It shares physical hardware resources with other users but isolates the operating system. The end user has the same experience on a VM as they would have on dedicated hardware. 
* In contrast, a **container** is a standard unit of software that packages up code and all its dependencies so the application runs quickly and reliably from one computing environment to another (far more lightweight than VMs).

.columns[
.column[
.img-med[
![](assets/vm_stack.png)
]
]
.column[
.img-med[
![](assets/container_stack.png)
]
]
]

.center[Attribution: Docker Documentation, https://docs.docker.com/; [The Turing Way](https://the-turing-way.netlify.com/reproducible_environments/01/options.html)]

---
# Containerisation
* The use of Linux containers to deploy applications is called **containerisation**.
* The most popular and well supported platforms to develop, deploy and run applications with containers are [Docker](https://www.docker.com/) and [Singularity](https://sylabs.io/singularity/), which will be the focus of this workshop.

.columns[
.column[
.img-med[
![](assets/docker_logo.png)
]
]
.column[
.img-med[
![](assets/singularity.png)
]
]
]
---
# Terminology: Images and Containers

A container is launched by running an image.

* An **image** is a lightweight, standalone, executable package of software that includes everything needed to run an application: code, runtime, system tools, system libraries and settings.
* A **container** is a runtime instance of an image - what the image becomes in memory when executed.

.center[![](assets/Image_Container.svg)]

.center[Attribution: Get started with Docker, https://docs.docker.com/get-started/]
---
# Terminology: Host

* The **host** machine is the machine running the container engine (such as Docker or Singularity), on which images and containers are stored

.img-half[
![](assets/Host.png)
]

.center[Attribution: [Melbourne Bioinformatics' Containerized Bioinformatics tutorial](https://www.melbournebioinformatics.org.au/tutorials/tutorials/docker/docker/)]
---
# Advantages

Distributing and using software as a container image gives you:
* **Bundled Dependencies** – they contain all their own dependencies, which means you don’t have to do any installation yourself
* **Cross-platform Installation** – they contain their own operating system, so they will run on any platform (even Windows!)
* **Easy Distribution** - they can be distributed as a single .tar image file, or put on [Docker Hub](https://hub.docker.com/) so it can be `docker pull`'d (or on [Singularity Hub](https://singularity-hub.org/) and `singularity pull`'d)
* **Safety** – files in a container can’t access files on the host machine, so users can trust containerised applications
* **Ease-of-Use** – they can always be run using a single run command
* **Easy Upgrades** – they can be easily swapped out for newer versions, while all persistent data can be retained in a data volume

.center[Attribution: [Melbourne Bioinformatics' Containerized Bioinformatics tutorial](https://www.melbournebioinformatics.org.au/tutorials/tutorials/docker/docker/)]
---
class: center, middle
# Part 2
## Docker
---
# Docker: Test installation 1

.message.is-info[
.message-header[
Exercise
]
.message-body[
Run the following command to ensure that you have a supported version of Docker. What does it output?
```
docker --version
``` 
]
]

--

.message.is-success[
.message-header[
Answer
]
.message-body[
```
Docker version 19.03.1, build 74b1e89
```
]
]
---
# Docker: Test installation 2

.message.is-info[
.message-header[
Exercise
]
.message-body[
Run the following command to view even more details about your Docker installation. What does it output?
```
docker info
```
]
]

--

.message.is-success[
.message-header[
Answer
]
.message-body[
```
Containers: 0
 Running: 0
 Paused: 0
 Stopped: 0
Images: 0
Server Version: 19.03.1
Storage Driver: overlay2
...
```
]
]
---
# Docker: Test installation 3

.message.is-info[
.message-header[
Exercise
]
.message-body[
Run the following command for the list of available Docker commands. What does it output?
```
docker --help
```
]
]

--

.message.is-success[
.message-header[
Answer
]
.message-body[
```
Usage:	docker [OPTIONS] COMMAND

A self-sufficient runtime for containers

Options:
      --config string      Location of client config files (default "/Users/rachael/.docker")
  -c, --context string     Name of the context to use to connect to the daemon (overrides DOCKER_HOST env var and default context set with "docker context use")
  -D, --debug              Enable debug mode
  -H, --host list          Daemon socket(s) to connect to
  -l, --log-level string   Set the logging level ("debug"|"info"|"warn"|"error"|"fatal") (default "info")
...
```
]
]
---
# Docker: 'Hello world!'

* The most basic command to run a container image is: `docker run <IMAGE NAME>`

.message.is-info[
.message-header[
Exercise
]
.message-body[
Run the following command. What does it output?

```
docker run hello-world
```
]
]

--

.message.is-success[
.message-header[
Answer
]
.message-body[
```
Unable to find image 'hello-world:latest' locally
latest: Pulling from library/hello-world
ca4f61b1923c: Pull complete
Digest: sha256:ca0eeb6fb05351dfc8759c20733c91def84cb8007aa89a5bf606bc8b315b9fc7
Status: Downloaded newer image for hello-world:latest

Hello from Docker!
This message shows that your installation appears to be working correctly.
```
]
]
---
# Docker: Docker Hub 1

* When you ran `docker run hello-world`, Docker first looked for the image on your local machine, and if it couldn't find it, pulled it down from a cloud registry of Docker images called **Docker Hub**
* You can find an image for most applications and runtimes on Docker Hub, which has a web interface located at: https://hub.docker.com/  

--

* If you want to pre-download a particular container image, use `docker pull` to retrieve it from its registry: 
 ```
 docker pull [OPTIONS] NAME[:TAG|@DIGEST]
 ```
* If no tag is provided, Docker uses the `:latest` tag as a default. For example, this command pulls the [`ubuntu:latest`](https://hub.docker.com/_/ubuntu) image:
 ```
 docker pull ubuntu
 ```

--

* Pay careful attention to the documentation on the image's Docker Hub page - it often contains critical information such as what version of the software is being contained and the relevant tags for each version.  
* See the [docker pull reference](https://docs.docker.com/engine/reference/commandline/pull/) for available options.
 
---
# Docker: Docker Hub 2

.message.is-info[
.message-header[
Exercise
]
.message-body[
Search on [Docker Hub](https://hub.docker.com/) for the best container image for running `python` applications. What command would you run if you wanted to pull this container image?

Hint: The command to pull the image is located in the top right of its Docker Hub page. [And it will take a minute or two to download.]
]
]
--
.message.is-success[
.message-header[
Answer
]
.message-body[
![https://hub.docker.com/_/python](assets/docker_hub_python.png)

```
docker pull python 
```
]
]
---
# Docker: Listing Images

* Images that you have installed locally can be viewed using `docker images`

.message.is-info[
.message-header[
Exercise
]
.message-body[
Run the following command to view all images installed on your machine:
```
docker images
```
]
]
--
.message.is-success[
.message-header[
Answer
]
.message-body[
```
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
python                 latest              60e318e4984a        15 hours ago        918MB
hello-world            latest              fce289e99eb9        7 months ago        1.84kB
```
]
]
---
# Docker: Listing containers 1
* `docker ps` lists all currently running containers
* You can also show all terminated containers using the `-a` flag
* The IDs that are shown can be useful for other docker commands like `docker stop` and `docker exec`

.message.is-info[
.message-header[
Exercise
]
.message-body[
Try running the command:
```
docker ps
```
]
]

--

.message.is-success[
.message-header[
Answer
]
.message-body[
```
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
```

Nothing is listed because we don't currently have any running containers!
]
]
---
# Docker: Listing containers 2
* `docker ps` lists all currently running containers
* You can also show all terminated containers using the `-a` flag
* The IDs that are shown can be useful for other docker commands like `docker stop` and `docker exec`

.message.is-info[
.message-header[
Exercise
]
.message-body[
Try running the command:
```
docker ps -a
```
]
]

--

.message.is-success[
.message-header[
Answer
]
.message-body[
```
CONTAINER ID        IMAGE               COMMAND              CREATED             STATUS                         PORTS               NAMES
05ca30abafbb        hello-world         "/hello"             2 hours ago         Exited (0) 2 hours ago                             cranky_hamilton
```

Using the `-a` flag lists our previously run containers.
]
]

---
# Docker: Running containers 1

* The complete `docker run` usage is of the form:
  ```
  docker run [DOCKER OPTIONS] IMAGE[:TAG|@DIGEST] [COMMAND] [ARG...]
  ```
* This means that arguments that affect the way Docker runs must always go before the image name, but arguments that are passed to the image itself (such as the commands that will run within the container) must go after the image name.
* You can run `docker run --help` to see the list of available options or visit the [docker run reference](https://docs.docker.com/engine/reference/run/) for more information.

---
# Docker: Running containers 2

* The complete `docker run` usage is of the form:
  ```
  docker run [DOCKER OPTIONS] IMAGE[:TAG|@DIGEST] [COMMAND] [ARG...]
  ```

.message.is-info[
.message-header[
Exercise
]
.message-body[
Run the following command to find out which version of Python is used in the `python` image we pulled:
```
docker run python python --version
```
In this example,
* The first instance of `python` references the image name (with default tag `:latest`).
* `python --version` is the command being run inside the container.
* What is the output?
]
]
--
.message.is-success[
.message-header[
Answer
]
.message-body[
```
Python 3.7.4
```
]
]
---
# Docker: Running containers 3

Because container images on Docker Hub and other registries are often updated, the container version labelled with the default `:latest` tag will change. It is therefore best practice to reference the container image you use with more specific identifiers such as `Image[:tag]` or `Image[@digest]`. While not strictly a means of identifying a container, you can specify a version of an image you’d like to run the container with by adding `image[:tag]` to the command.  

.message.is-info[
.message-header[
Exercise
]
.message-body[
Check out the list of available tags for the `python` container image on its Docker Hub page: https://hub.docker.com/_/python

In the previous exercise, we saw that the version of Python used in the image with the `:latest` tag was 3.7.4. However, if we knew in advance which version of Python we wanted, we could run `docker run python:3.7.4` for example to specify that we want to use Python version 3.7.4. Run the following command - what is the output?
```
docker run python:3.7.4 python --version
```
]
]
--
.message.is-success[
.message-header[
Answer
]
.message-body[
```
Unable to find image 'python:3.7.4' locally
3.7.4: Pulling from library/python
Digest: sha256:5f980d2673056ca33580979bcfb70c82f70ceccf857b77b740da40701e5d473e
Status: Downloaded newer image for python:3.7.4
Python 3.7.4
```
]
]
---

# Docker: Running containers 4

The goal is to be as specific as possible when using and referencing container images, so that if the image is updated in the future, others can still identify and use the same containerised software to reproduce your work. The most specific way to reference the container image you're using is by its unique identifier called its **digest** in the following way: `Image[@digest]` 

.message.is-info[
.message-header[
Exercise
]
.message-body[
The following example runs the container from the `python` version 3.7.4 image with the `sha256:5f980d2673056ca33580979bcfb70c82f70ceccf857b77b740da40701e5d473e` digest (from the previous slide):

```
docker run python@sha256:5f980d2673056ca33580979bcfb70c82f70ceccf857b77b740da40701e5d473e python --version
```
]
]
--
.message.is-success[
.message-header[
Answer
]
.message-body[
```
Python 3.7.4
```
]
]
---
# Docker: Running containers 5

Some commonly used `docker run` options that you can set include:
* `--detach , -d` : Run container in background and print container ID
* `--name` : Assign a name to the container
* `--publish , -p` : Publish a container’s port(s) to the host
* `--rm` : Automatically remove the container when it exits
* `--volume , -v` : Bind mount a volume (such as the directory containing your data, scripts, application)
* `--workdir , -w` : Working directory inside the container

---
# Docker: Running containers 6 - Volumes and Bind Mounts
* By default, Docker containers cannot access data on the host system. This means
	* You can't use host data in your containers
	* All data stored in the container will be lost when the container exits
* You can solve this in two ways:
	* `-v /path/in/host:/path/in/container`: This **bind mounts** a host file or directory into the container. Writes to one will affect the other. Note that both paths have to be *absolute* paths, so you often want to use
```
`pwd`/some/path
```
	* `-v volume_name:/path/in/container`. This mounts a **named volume** into the container, which will live separately from the rest of your files. This is preferred, unless you need to access or edit the files from the host

---
# Docker: Running containers 7 

.message.is-info[
.message-header[
Exercise
]
.message-body[
1\. Create a folder locally on your computer. For example:  
```
cd Desktop
mkdir container_workshop
cd container_workshop
```
2\. Create a simple python script using the example from the Reproducible Environments: Importance slide. For example:  
```
vim script.py
```
and within the script, copy and paste:  
```
a = 1
b = 5
print(a/b)
```
]
]

---
# Docker: Running containers 7 

.message.is-info[
.message-header[
Exercise
]
.message-body[
3\. Run the script using the `python` Docker container image for Python 2 (see the [python Docker Hub image page](https://hub.docker.com/_/python) for usage). The command syntax is of the form:  
```
docker run [OPTIONS] IMAGE [COMMAND] [ARG...]
```
See the [docker run reference](https://docs.docker.com/engine/reference/commandline/run/) for available options.
]
]
--
.message.is-success[
.message-header[
Answer
]
.message-body[
```
docker run -it --rm -v "$PWD":/python_test -w /python_test python:2 python script.py

0
```
]
]

---
# Docker: Running containers 7 

.message.is-info[
.message-header[
Exercise
]
.message-body[
4\. Run the script using the `python` Docker container image for Python 3 (see the [python Docker Hub image page](https://hub.docker.com/_/python) for usage). The command syntax is of the form:
```
docker run [OPTIONS] IMAGE [COMMAND] [ARG...]
```
See the [docker run reference](https://docs.docker.com/engine/reference/commandline/run/) for available options.
]
]
--
.message.is-success[
.message-header[
Answer
]
.message-body[
```
docker run -it --rm -v "$PWD":/python_test -w /python_test python:3 python script.py

0.2
```
]
]

---
# Docker: Running containers 8 - Port Mapping
* Docker containers are free to listen on whatever ports to want to, for example port 80/443 for web requests
* However, these ports are not available on the host machine unless you use
  ```
  docker run -p host:container <IMAGE NAME>
  ```
* This command means "map port 8080 inside this container to port 80 on the host machine"
  ```
  docker run -p 80:80 <IMAGE NAME>
  ```
* Note that the host port and container port *can be the same*, and this is quite common

.center[![](assets/Ports.svg)]

---
# Docker: Running containers 9 - Detached Mode
* If you ever need a container to run in the background, use the `-d` docker flag. For instance, we could have run: 
  ```
  docker run -d -p 80:80 <IMAGE NAME>
  ```
* Docker then prints out the ID of the container, allowing you to access it later:
  ```
  e0d19a8b903015d01a1456a8c9b2351f540b240c0f596030e1d4cd85f9d6956a
  ```
---
# Docker Stop
* Ordinarily, you can press `ctrl+c` to stop a container currently running in your terminal
* However, if the container is running in the background (with `-d`), or refuses to close, you can use `docker stop`
```bash
docker stop <CONTAINER ID>
```

.message.is-info[
.message-header[
Exercise
]
.message-body[
* Use `docker stop` if you to close the currently running Galaxy Docker container
* Hint: use `docker ps` if you've forgotten the container's ID
]
]

---
# Running commands inside a container
* You can run a command inside a running container using:
```bash
docker exec <CONTAINER ID> <COMMAND>
```
* For example:
```bash
docker exec bd2ac6cce96f ls
```
* You can also run an interactive bash session inside the container with:
```bash
docker exec -it bd2ac6cce96f bash
```
---
# Running a Container Interactively
.message.is-info[
.message-header[
Exercise
]
.message-body[
* Start another Galaxy container using:
```bash
docker run -d -p 80:80 bgruening/galaxy-stable
```
* Now, you want to make a quick edit to the Galaxy homepage, which is located at `/etc/galaxy/web/welcome.html`
* Edit the welcome message in some way, save the file, and then check to see if your changes worked on the website
* You'll probably have to re-open the webpage in an incognito window to get it to refresh
]
]

---
# Running a Container Interactively
.message.is-success[
.message-header[
Exercise
]
.message-body[
* First, `docker ps` to find the container ID
* Next, `docker exec -it <CONTAINER_ID> bash`
* Now, run `nano /etc/galaxy/web/welcome.html` (or vim!) and save the file
]
]
---
# Summary
The Docker commands we've covered so far are:
* `docker [-d] [-p host:container] [-v /host/path:/container/path] run <IMAGE NAME>`, which runs a Docker image
* `docker images`, which displays all installed images
* `docker ps [-a]`, which displays all containers on the system
* `docker exec <CONTAINER ID> <COMMAND>`, which lets you run a command inside a running container
* `docker stop <CONTAINER ID>`, which stops a running container
---
class: center, middle
# Part 3
## Making your Own Image
---
# Dockerfiles
* The core of making a Docker image is a Dockerfile
* These files should have the exact name `Dockerfile`, and should be located in their own directory
* A Dockerfile is a list of commands, a lot like a shell script, that progressively builds the image:
    * `FROM` lists the image to "inherit" from
    * `RUN` executes a shell command
    * `COPY` copies some data from the host to the image
    * `ENTRYPOINT` sets the command that will be run when a container is created
    * `WORKDIR`, like `cd`, sets the current working directory for the build script
---
# Dockerfiles - Example
```
# Start with an empty Ubuntu image
FROM ubuntu

# Install apt dependencies
RUN apt-get update && apt-get install -y curl make build-essential libssl-dev

# Copy in the repository
COPY . /opt/cpipe

# Move into the cpipe dir
WORKDIR /opt/cpipe

# Run the install script
RUN ./install.sh --noninteractive

# Run the main script
ENTRYPOINT ["./cpipe"]
```
---
# Dockerfile Tips
* You should try to separate the Dockerfile into as many stages as possible, because this will allow for better caching
* `apt-get`:
	* You must run `apt-get update` and `apt-get install` in the same command, otherwise you will encounter caching issues
	* Remember to use `apt-get install -y`, because you will have no control over the process while it's building
* Useful resources:
	* [Dockerfile reference](https://docs.docker.com/engine/reference/builder/)
	* [Best practices](https://docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices/)
---
# Docker Build
* To build a Docker image from a Dockerfile, use the `docker build` command
* You should specify an image tag/name using `-t`, and a directory containing the Dockerfile. For example:
```bash
docker build -t my_image .
```
---
# Exercise - Dockerizing Samtools
* Samtools is a common utility for working with SAM and BAM alignment files
* Samtools can be installed using `apt-get install samtools`

.message.is-info[
.message-header[
Exercise
]
.message-body[
* Create a Dockerfile for samtools inside its own directory, and build it using `docker build`
* Make sure you tag it as `my_samtools`, we'll need it later on
* You'll also need to set the entrypoint to the `samtools` command
* Once it's finished, try testing it using the SAM file provided:

```bash
docker run -i my_samtools view -H - < data/alignment.sam
```
]
]

---
# Exercise - Dockerizing Samtools
.message.is-success[
.message-header[
Solution
]
.message-body[
`my_samtools/Dockerfile`:
```
FROM ubuntu
RUN apt-get update && apt-get install -y samtools
ENTRYPOINT ["samtools"]
```
Building:
```bash
docker build -t my_samtools my_samtools/
```
]
]

---
# Exercise - Dockerizing BWA
* bwa can be installed in much the same way as samtools

.message.is-info[
.message-header[
Exercise
]
.message-body[
* Try making a Dockerfile for `bwa`
* Make sure you tag this as `my_bwa`
* The image is probably working if it prints out the `bwa` help when you run the image
]
]

--

.message.is-success[
.message-header[
Exercise
]
.message-body[
`my_bwa/Dockerfile`:
```
FROM ubuntu
RUN apt-get update && apt-get install -y bwa
ENTRYPOINT ["bwa"]
```

Building:
```bash
docker build -t my_bwa my_bwa/
```
]
]
---
# Exercise - Dockerizing Freebayes
* Freebayes is an open-source variant caller (calculates how a given individual's DNA differs from a reference genome)
* Freebayes is a little harder to install - you'll need to build it from source
* Installation instructions for Freebayes can be found here: https://github.com/ekg/freebayes#obtaining

.message.is-info[
.message-header[
Exercise
]
.message-body[
* Try making a Dockerfile for `freebayes`
* As a tip, the apt-get repositories you need for this will be: `git build-essential zlib1g-dev libbz2-dev liblzma-dev`
* Make sure you tag this as `my_freebayes`
]
]

---
# Exercise - Dockerizing Freebayes
.message.is-success[
.message-header[
Solution
]
.message-body[
`my_bwa/freebayes`:
```
FROM ubuntu
RUN apt-get update && apt-get install -y git build-essential zlib1g-dev libbz2-dev liblzma-dev
WORKDIR /tmp
RUN git clone --recursive git://github.com/ekg/freebayes.git
WORKDIR freebayes
RUN make
RUN make install
ENTRYPOINT ["freebayes"]
```

Building:
```bash
docker build -t my_freebayes my_freebayes/
```
]
]

---
# Dockerized Pipelines
* Docker containers are often used to provide the tools and runtime environment for each stage in a bioinformatics pipeline
* A number of workflow frameworks support Docker:
	* Broad's WDL
	* CWL (Common Workflow Language)
	* Galaxy

![](assets/Docker Workflows.svg)

---
# Dockerized Pipelines
Conveniently, the images you just make are just the right ones for running a variant calling pipeline
.message.is-info[
.message-header[
Exercise
]
.message-body[
Try running
```bash
cwltool cwl_workflow/workflow.cwl \
	--read_1 data/NA12878_CARDIACM_MUTATED_L001_R1.fastq.gz \
	--read_2 data/NA12878_CARDIACM_MUTATED_L001_R2.fastq.gz \
	--reference data/ucsc.hg19.fasta
```
]
]

And while that's running, we'll move onto the next topic...
---
class: center, middle
# Part 4
## Docker on HPC
---
# Docker on HPC
* Security on HPC:
	* If you have Docker access, you effectively have `root` permissions over the entire operating system
	* This works fine on the cloud, where instances are rarely shared between multiple users
	* However on HPC (computing clusters etc), this would allow Docker users to access each other's files
	* For this reason, it is unlikely you will find Docker installed on an HPC system
* A few alternatives exist for running containers on HPC, but there's only one that really matters
	* [Singularity](http://singularity.lbl.gov/) - A ground-up reimplementation of Docker, with a fairly different CLI. Actively developed.

.columns.is-centered[
.column.is-narrow[
.image.is-128x128[
![](assets/singularity.png)
]
]
]
---
# Converting a Docker Image
* Unlike Docker, Singularity stores its images as individual files
* You can convert a docker image to a singularity image using Singularity:
```bash
singularity build [IMAGE NAME].sif docker-daemon://[IMAGE NAME]:latest
```

.message.is-info[
.message-header[
Exercise
]
.message-body[
Using the command above, try creating a singularity image from your `my_samtools` image
]
]

---
# Running a Singularity Image
.message.is-info[
.message-header[
Exercise
]
.message-body[
Test out that your singularity image works properly using:
```bash
singularity run [IMAGE FILE] view -H < data/alignment.sam
```
]
]
---
class: left, middle
# Summary and Closing

After the workshop, participants should know:
* What containerisation is and why they might use it in their research.
* Some common containerisation tools and when to use them.
* How to find and run containers built by other people.
* How to build their own container.
* How to distribute their container online.
---
class: center, middle
# That's All
