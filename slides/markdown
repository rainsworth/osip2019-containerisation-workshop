class: left, middle
# Reproducible Research through Containerisation:
##  Docker and Singularity
<br><br>
[Open Science In Practice](http://osip2019.epfl.ch/)  
EPFL, Lausanne, Switzerland  
11:00-13:00, 5 September 2019  
<br><br>
Speaker: Dr. Rachael Ainsworth, University of Manchester  
Twitter: [@rachaelevelyn](https://twitter.com/rachaelevelyn), GitHub: [@rainsworth](https://github.com/rainsworth/)
---
layout: true
class: content
---
class: left, middle
# Acknowledgements

Resources used to develop this workshop:
* _The Turing Way_: [GitHub](https://github.com/alan-turing-institute/the-turing-way), [Book](https://the-turing-way.netlify.com), [Zenodo](http://doi.org/10.5281/zenodo.3233986)
* [Melbourne Bioinformatics' Containerized Bioinformatics tutorial](https://www.melbournebioinformatics.org.au/tutorials/tutorials/docker/docker/)
* [Getting started with Docker](https://docs.docker.com/get-started/)
---
class: left, middle
# Dr. Rachael Ainsworth

* Research Associate & Open Science Champion, University of Manchester
* Software Sustainability Institute Fellow
* FOSTER Open Science Trainer
* Mozilla Open Leader (Round 4 Project Lead, Round 5 Mentor & Cohort Host)
* _The Turing Way_ Core Contributor
* HER+Data MCR Organiser
* Likes meeting new people, learning new things, coffee & travelling.
* Twitter: [@rachaelevelyn](https://twitter.com/rachaelevelyn)  
* GitHub: [@rainsworth](https://github.com/rainsworth/)

---
class: left, middle
# Agenda

1. Learning objectives
2. Feedback practice: Software Carpentry style traffic lights
3. Introduction to Reproducibility through Containerisation
4. Exercise: Hello world!
5. Comfort break
6. Exercise: Run an application in an existing container
7. Exercise: Build your own container
8. Exercise: Upload your container to DockerHub
9. Summary and closing

---
class: center, middle
# Learning Objectives
---
class: left, middle
# Learning Objectives

After the workshop, participants should know:
* What containerisation is and why they might use it in their research.
* Some common containerisation tools and when to use them.
* How to find and run containers built by other people.
* How to build their own container.
* How to distribute their container online.
---
class: center, middle
# Part 0
## Feedback practice: Software Carpentry style traffic lights
---
class: left, middle
# Feedback practice: traffic lights

Indicate how much you agree with the follow statements using Software Carpentry style traffic lights.

.center[
#### I feel fully caffeinated this morning.
]

.columns[
  .column[.center[Agree]
    ![](assets/postit-green.png)
  ]
  .column[.center[Disagree]
    ![](assets/postit-red.png)
  ]
]

.center[Attribution: Alex Morley http://doi.org/10.5281/zenodo.2598522]
---
# Feedback practice: traffic lights

Indicate how much you agree with the follow statements using Software Carpentry style traffic lights.

.center[
#### Today I am using: Linux (any flavour).
]

.columns[
  .column[.center[Agree]
    ![](assets/postit-green.png)
  ]
  .column[.center[Disagree]
    ![](assets/postit-red.png)
  ]
]

.center[Attribution: Alex Morley http://doi.org/10.5281/zenodo.2598522]
---
# Feedback practice: traffic lights

Indicate how much you agree with the follow statements using Software Carpentry style traffic lights.

.center[
#### Today I am using: Mac (OSX).
]

.columns[
  .column[.center[Agree]
    ![](assets/postit-green.png)
  ]
  .column[.center[Disagree]
    ![](assets/postit-red.png)
  ]
]

.center[Attribution: Alex Morley http://doi.org/10.5281/zenodo.2598522]
---
# Feedback practice: traffic lights

Indicate how much you agree with the follow statements using Software Carpentry style traffic lights.

.center[
#### Today I am using: Windows.
]

.columns[
  .column[.center[Agree]
    ![](assets/postit-green.png)
  ]
  .column[.center[Disagree]
    ![](assets/postit-red.png)
  ]
]

.center[Attribution: Alex Morley http://doi.org/10.5281/zenodo.2598522]
---
# Feedback practice: traffic lights

Indicate how much you agree with the follow statements using Software Carpentry style traffic lights.

.center[
#### I have installed Docker.
]

.columns[
  .column[.center[Agree]
    ![](assets/postit-green.png)
  ]
  .column[.center[Disagree]
    ![](assets/postit-red.png)
  ]
]

.center[Attribution: Alex Morley http://doi.org/10.5281/zenodo.2598522]
---
# Feedback practice: traffic lights

Indicate how much you agree with the follow statements using Software Carpentry style traffic lights.

.center[
#### I have some previous experience using containers.
]

.columns[
  .column[.center[Agree]
    ![](assets/postit-green.png)
  ]
  .column[.center[Disagree]
    ![](assets/postit-red.png)
  ]
]

.center[Attribution: Alex Morley http://doi.org/10.5281/zenodo.2598522]
---
class: center, middle
# Part 1
## Introduction to Reproducibility through Containerisation
---
# Reproducibility

.img-med[
![](assets/1728_TURI_Book sprint_39 reproducible replicable robust generalisable_040619.jpg)
]

.center[Attribution: The Turing Way Community & Scriberia, http://doi.org/10.5281/zenodo.3332808]
---
# Reproducibility Spectrum

.img-med[
![](assets/ReproducibilitySpectrum.jpg)
]

> Computational science has led to exciting new developments, but the nature of the work has exposed limitations in our ability to evaluate published findings. Reproducibility has the potential to serve as a minimum standard for judging scientific claims when full independent replication of a study is not possible.”  

>(Peng 2011; https://doi.org/10.1126/science.1213847)

---
class: center, middle
# "But it worked on my laptop..."
---
# Reproducible Environments: Importance

Simple Python script example:

```
a = 1
b = 5
print(a/b)
```

--

* Output of 1 divided by 5 in Python 3: `0.2`

--

* Output of 1 divided by 5 in Python 2: `0`

--

* This is because integer division is applied to integers in Python 2, but (normal) division is applied to all types, including integers, in Python 3.  

--

* This very simple script returns _different_ answers depending on the computational environment in which it is run. 
* Using the wrong version of Python is easy to do, and demonstrates how a perfectly valid piece of code can give different results depending on its environment. 
* If such issues can impact a simple script like this, imagine how many could appear in a complex analysis procedure which may involve thousands of lines of code and dozens of dependent packages!

.center[Attribution: [The Turing Way](https://the-turing-way.netlify.com/reproducible_environments/01/options.html)]
---
# Reproducible Environments: Impact

It is vital for researchers to understand and capture the computational environments in which they are conducting their work, as it has the potential to impact:

* **You**: Your working environment evolves over time as you update software, install new software and move to different computers. If the project environment is not captured and you need to return to that project after months or years (as is common in research), you may have no way of knowing what changes to the environment have occurred. This will impact your ability to run the code and on the results.

--

* **Your collaborators**: Research is collaborative, and conducting research in multiple different computational environments opens up a minefield of potential bugs. Trying to fix these kinds of issues is often time consuming and frustrating as researchers have to figure out what the differences between computational environments are and their effects. Worse, some bugs may remain undetected, potentially impacting the results.

--

* **Science**: How research is conducted has evolved significantly over the past decade, but the same cannot be said for the methods by which research processes are captured and disseminated. Research articles alone are no longer sufficient to verify, reproduce and extend scientific results. For research to be reproducible, researchers must publish and distribute the entire contained analysis, not just its results. Any research that is limited to where it can be deployed is instantly limited in the extent that it can be reproduced.

.center[Attribution: [The Turing Way](https://the-turing-way.netlify.com/reproducible_environments/01/options.html)]
---
# Reproducible Environments: Options

.img-med[
![](assets/ReproducibleEnvironments.png)
]

.center[Attribution: [The Turing Way](https://the-turing-way.netlify.com/reproducible_environments/01/options.html)]
---
# Virtual Machines (VMs) vs Containers

* A **virtual machine (VM)** is a program that emulates a complete computer and imitates dedicated hardware. It shares physical hardware resources with other users but isolates the operating system. The end user has the same experience on a VM as they would have on dedicated hardware. 
* In contrast, a **container** is a standard unit of software that packages up code and all its dependencies so the application runs quickly and reliably from one computing environment to another (far more lightweight than VMs).

.columns[
.column[
.img-med[
![](assets/vm_stack.png)
]
]
.column[
.img-med[
![](assets/container_stack.png)
]
]
]

.center[Attribution: Docker Documentation, https://docs.docker.com/; [The Turing Way](https://the-turing-way.netlify.com/reproducible_environments/01/options.html)]

---
# Containerisation
* The use of Linux containers to deploy applications is called **containerisation**.
* The most popular and well supported platforms to develop, deploy and run applications with containers are [Docker](https://www.docker.com/) and [Singularity](https://sylabs.io/singularity/), which will be the focus of this workshop.

.columns[
.column[
.img-med[
![](assets/docker_logo.png)
]
]
.column[
.img-med[
![](assets/singularity.png)
]
]
]
---
# Terminology: Images and Containers

A container is launched by running an image.

* An **image** is a lightweight, standalone, executable package of software that includes everything needed to run an application: code, runtime, system tools, system libraries and settings.
* A **container** is a runtime instance of an image - what the image becomes in memory when executed.

.center[![](assets/Image_Container.svg)]

.center[Attribution: Get started with Docker, https://docs.docker.com/get-started/]
---
# Terminology: Host

* The **host** machine is the machine running the container engine (such as Docker or Singularity), on which images and containers are stored

.img-half[
![](assets/Host.png)
]

.center[Attribution: [Melbourne Bioinformatics' Containerized Bioinformatics tutorial](https://www.melbournebioinformatics.org.au/tutorials/tutorials/docker/docker/)]
---
# Advantages

Distributing and using software as a container image gives you:
* **Bundled Dependencies** – they contain all their own dependencies, which means you don’t have to do any installation yourself
* **Cross-platform Installation** – they contain their own operating system, so they will run on any platform (even Windows!)
* **Easy Distribution** - they can be distributed as a single .tar image file, or put on [Docker Hub](https://hub.docker.com/) so it can be `docker pull`'d (or on [Singularity Hub](https://singularity-hub.org/) and `singularity pull`'d)
* **Safety** – files in a container can’t access files on the host machine, so users can trust containerised applications
* **Ease-of-Use** – they can always be run using a single run command
* **Easy Upgrades** – they can be easily swapped out for newer versions, while all persistent data can be retained in a data volume

.center[Attribution: [Melbourne Bioinformatics' Containerized Bioinformatics tutorial](https://www.melbournebioinformatics.org.au/tutorials/tutorials/docker/docker/)]
---
class: center, middle
# Part 2
## Docker
---
# Docker: Test installation 1

.message.is-info[
.message-header[
Exercise
]
.message-body[
Run the following command to ensure that you have a supported version of Docker. What does it output?
```
docker --version
``` 
]
]

--

.message.is-success[
.message-header[
Answer
]
.message-body[
```
Docker version 19.03.1, build 74b1e89
```
]
]
---
# Docker: Test installation 2

.message.is-info[
.message-header[
Exercise
]
.message-body[
Run the following command to view even more details about your Docker installation. What does it output?
```
docker info
```
]
]

--

.message.is-success[
.message-header[
Answer
]
.message-body[
```
Containers: 0
 Running: 0
 Paused: 0
 Stopped: 0
Images: 0
Server Version: 19.03.1
Storage Driver: overlay2
...
```
]
]
---
# Docker: Test installation 3

.message.is-info[
.message-header[
Exercise
]
.message-body[
Run the following command for the list of available Docker commands. What does it output?
```
docker --help
```
]
]

--

.message.is-success[
.message-header[
Answer
]
.message-body[
```
Usage:	docker [OPTIONS] COMMAND

A self-sufficient runtime for containers

Options:
      --config string      Location of client config files (default "/Users/rachael/.docker")
  -c, --context string     Name of the context to use to connect to the daemon (overrides DOCKER_HOST env var and default context set with "docker context use")
  -D, --debug              Enable debug mode
  -H, --host list          Daemon socket(s) to connect to
  -l, --log-level string   Set the logging level ("debug"|"info"|"warn"|"error"|"fatal") (default "info")
...
```
]
]
---
# Docker: 'Hello world!'

* The most basic command to run a container image is: `docker run <IMAGE NAME>`

.message.is-info[
.message-header[
Exercise
]
.message-body[
Run the following command. What does it output?

```
$ docker run hello-world
```
]
]

--

.message.is-success[
.message-header[
Answer
]
.message-body[
```
Unable to find image 'hello-world:latest' locally
latest: Pulling from library/hello-world
ca4f61b1923c: Pull complete
Digest: sha256:ca0eeb6fb05351dfc8759c20733c91def84cb8007aa89a5bf606bc8b315b9fc7
Status: Downloaded newer image for hello-world:latest

Hello from Docker!
This message shows that your installation appears to be working correctly.
```
]
]
---
# Docker: Docker Hub

* When you ran `docker run hello-world`, Docker first looked for the image on your local machine, and if it couldn't find it, pulled it down from a cloud registry of Docker images called **Docker Hub**
* You can find an image for most applications and runtimes on Docker Hub, which has a web interface located at: https://hub.docker.com/  
--
* To download a particular container image, use `docker pull`: 
```
$ docker pull [OPTIONS] NAME[:TAG|@DIGEST]
```
* If no tag is provided, Docker uses the `:latest` tag as a default. For example, this command pulls the `debian:latest` image:
```
$ docker pull debian
```
* See the [docker pull reference](https://docs.docker.com/engine/reference/commandline/pull/) for available options.
 
---
# Docker: Docker Hub

.message.is-info[
.message-header[
Exercise
]
.message-body[
Search on [Docker Hub](https://hub.docker.com/) for the best container image for running `python` applications. What image name would you call if you wanted to pull this container?
]
]
--
.message.is-success[
.message-header[
Answer
]
.message-body[
![](assets/docker_hub_python.png)

```
$ docker pull python 
```
]
]
---
# Docker: Image Tags

.message.is-info[
.message-header[
Exercise
]
.message-body[
Search on [Docker Hub](https://hub.docker.com/) for the best container image for running `python` applications. What image name would you call if you wanted to run this container?
]
]
--
.message.is-success[
.message-header[
Answer
]
.message-body[
![](assets/docker_hub_python.png)
]
]
---
# Docker: Using existing container images 

.message.is-info[
.message-header[
Exercise
]
.message-body[
1\. Create a folder locally on your computer. For example:  
```
cd Desktop
mkdir container_workshop
cd container_workshop
```
2\. Create a simple python script using the example from the Reproducible Environments: Importance slide. For example:  
```
vim script.py
```
and within the script, copy and paste:  
```
a = 1
b = 5
print(a/b)
```
]
]

---
# Docker: Using existing container images 

.message.is-info[
.message-header[
Exercise
]
.message-body[
3\. Run the script using the `python` Docker container image for Python 2 (see the [python Docker Hub image page](https://hub.docker.com/_/python) for usage). The command syntax is of the form:  
```
docker run [OPTIONS] IMAGE [COMMAND] [ARG...]
```
See the [docker run reference](https://docs.docker.com/engine/reference/commandline/run/) for available options.
]
]
--
.message.is-success[
.message-header[
Answer
]
.message-body[
```
docker run -it --rm -v "$PWD":/python_test -w /python_test python:2 python script.py

0
```
]
]

---
# Docker: Using existing container images 

.message.is-info[
.message-header[
Exercise
]
.message-body[
4\. Run the script using the `python` Docker container image for Python 3 (see the [python Docker Hub image page](https://hub.docker.com/_/python) for usage). The command syntax is of the form:
```
docker run [OPTIONS] IMAGE [COMMAND] [ARG...]
```
See the [docker run reference](https://docs.docker.com/engine/reference/commandline/run/) for available options.
]
]
--
.message.is-success[
.message-header[
Answer
]
.message-body[
```
docker run -it --rm -v "$PWD":/python_test -w /python_test python:3 python script.py

0.2
```
]
]

---
# Listing Images
* Images that you have installed locally can be viewed using `docker images`

.message.is-info[
.message-header[
Exercise
]
.message-body[
Run the following command to view all images installed on your machine:
```
docker images
```
]
]
--
.message.is-success[
.message-header[
Answer
]
.message-body[
```
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
hello-world         latest              f2a91732366c        3 months ago        1.85kB
```
]
]
---
# Docker: Basic commands
* To see the list of images on your machine, run `docker image ls` or `docker images`:

```
docker image ls

REPOSITORY             TAG                 IMAGE ID            CREATED             SIZE
hello-world            latest              fce289e99eb9        7 months ago        1.84kB
```

--

* To see the list of containers which have been spawned by the images, run `docker container ls --all` or `docker ps --all`:

```
docker container ls --all

CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS
836421e7e92e        hello-world         "/hello"            2 minutes ago       Exited (0) 2 minutes ago
```

--

* To see containers that are currently running, you do not need the `--all` tag. For example, just `docker container ls` or `docker ps` for short.
---
# Docker Run Flags
* Docker Run is of the form:
```bash
docker run [docker options] <IMAGE NAME> [image arguments]
```
* This means that arguments that affect the way Docker runs must always go before the image name, but arguments that are passed to the image itself must go after the image name
* Run `docker run --help` to see the list of available options or visit the [docker run reference](https://docs.docker.com/engine/reference/run/) for more information.
---
# Port Mapping
* Docker containers are free to listen on whatever ports to want to, for example port 80/443 for web requests
* However, these ports are not available on the host machine unless you use
    ```bash
    docker run -p host:container <IMAGE NAME>
    ```
* This command means "map port 8080 inside this container to port 80 on the host machine"
    ```
    docker run -p 80:8080 <IMAGE NAME>
    ```
* Note that the host port and container port *can be the same*, and this is quite common

![](assets/Ports.svg)
---
# Port Mapping
.message.is-info[
.message-header[
Exercise
]
.message-body[
Run the following command to start an nginx server running on your cloud instance:
```bash
docker run -p 80:80 nginx
```
Now visit this server by typing in your cloud instance IP address into a web browser:
```
http://115.146.85.14
```
Stop the container using `Ctrl+C`, just like any process
]
]
---
# Detached Mode
* If you ever need a container to run in the background, use the `-d` docker flag. For instance, we
could have run:
```bash
docker run -d -p 80:80 nginx
```

* Docker then prints out the ID of the container, allowing you to access it later:
```
e0d19a8b903015d01a1456a8c9b2351f540b240c0f596030e1d4cd85f9d6956a
```

---
# Listing running containers
* `docker ps` lists all currently running containers
* Can also show all terminated containers with the `-a` flag
* The IDs that are shown can be useful for other docker commands like `docker stop` and `docker exec`

.message.is-info[
.message-header[
Exercise
]
.message-body[
Try running the command:
```bash
docker ps
```
]
]

--

.message.is-success[
.message-header[
Answer
]
.message-body[
```
CONTAINER ID        IMAGE                     COMMAND              CREATED             STATUS              PORTS                                                     NAMES
e0d19a8b9030        bgruening/galaxy-stable   "/usr/bin/startup"   2 minutes ago       Up 2 minutes        21/tcp, 443/tcp, 8800/tcp, 9002/tcp, 0.0.0.0:80->80/tcp   zen_leakey```
]
]
---
# Docker Stop
* Ordinarily, you can press `ctrl+c` to stop a container currently running in your terminal
* However, if the container is running in the background (with `-d`), or refuses to close, you can use `docker stop`
```bash
docker stop <CONTAINER ID>
```

.message.is-info[
.message-header[
Exercise
]
.message-body[
* Use `docker stop` if you to close the currently running Galaxy Docker container
* Hint: use `docker ps` if you've forgotten the container's ID
]
]
---
# Volumes and Bind Mounts
* By default, Docker containers cannot access data on the host system. This means
	* You can't use host data in your containers
	* All data stored in the container will be lost when the container exits
* You can solve this in two ways:
	* `-v /path/in/host:/path/in/container`: This **bind mounts** a host file or directory into the container. Writes to one will affect the other. Note that both paths have to be *absolute* paths, so you often want to use
```
`pwd`/some/path
```
	* `-v volume_name:/path/in/container`. This mounts a **named volume** into the container, which will live separately from the rest of your files. This is preferred, unless you need to access or edit the files from the host
---

# Exercise - Galaxy Logs
.message.is-info[
.message-header[
Exercise
]
.message-body[
* You need to store the logs for your Galaxy image on your host system using a bind mount
* The Galaxy container stores its logs in `/home/galaxy/logs`
* What command do you run?
* *Hint: You will want to run the container in detached mode*
* Once you have done this, `ls` the directory you mounted into the container to verify that you have the logs
]
]
--

.message.is-success[
.message-header[
Answer
]
.message-body[
```bash
docker run -d -v `pwd`/galaxy_logs:/home/galaxy/logs bgruening/galaxy-stable
```
]
]
---
# Exercise - Galaxy Logs
.message.is-info[
.message-header[
Exercise
]
.message-body[
Now, try to stop this container the same way we did last time
]
]
---
# Running commands inside a container
* You can run a command inside a running container using:
```bash
docker exec <CONTAINER ID> <COMMAND>
```
* For example:
```bash
docker exec bd2ac6cce96f ls
```
* You can also run an interactive bash session inside the container with:
```bash
docker exec -it bd2ac6cce96f bash
```
---
# Running a Container Interactively
.message.is-info[
.message-header[
Exercise
]
.message-body[
* Start another Galaxy container using:
```bash
docker run -d -p 80:80 bgruening/galaxy-stable
```
* Now, you want to make a quick edit to the Galaxy homepage, which is located at `/etc/galaxy/web/welcome.html`
* Edit the welcome message in some way, save the file, and then check to see if your changes worked on the website
* You'll probably have to re-open the webpage in an incognito window to get it to refresh
]
]

---
# Running a Container Interactively
.message.is-success[
.message-header[
Exercise
]
.message-body[
* First, `docker ps` to find the container ID
* Next, `docker exec -it <CONTAINER_ID> bash`
* Now, run `nano /etc/galaxy/web/welcome.html` (or vim!) and save the file
]
]
---
# Summary
The Docker commands we've covered so far are:
* `docker [-d] [-p host:container] [-v /host/path:/container/path] run <IMAGE NAME>`, which runs a Docker image
* `docker images`, which displays all installed images
* `docker ps [-a]`, which displays all containers on the system
* `docker exec <CONTAINER ID> <COMMAND>`, which lets you run a command inside a running container
* `docker stop <CONTAINER ID>`, which stops a running container
---
class: center, middle
# Part 3
## Making your Own Image
---
# Dockerfiles
* The core of making a Docker image is a Dockerfile
* These files should have the exact name `Dockerfile`, and should be located in their own directory
* A Dockerfile is a list of commands, a lot like a shell script, that progressively builds the image:
    * `FROM` lists the image to "inherit" from
    * `RUN` executes a shell command
    * `COPY` copies some data from the host to the image
    * `ENTRYPOINT` sets the command that will be run when a container is created
    * `WORKDIR`, like `cd`, sets the current working directory for the build script
---
# Dockerfiles - Example
```
# Start with an empty Ubuntu image
FROM ubuntu

# Install apt dependencies
RUN apt-get update && apt-get install -y curl make build-essential libssl-dev

# Copy in the repository
COPY . /opt/cpipe

# Move into the cpipe dir
WORKDIR /opt/cpipe

# Run the install script
RUN ./install.sh --noninteractive

# Run the main script
ENTRYPOINT ["./cpipe"]
```
---
# Dockerfile Tips
* You should try to separate the Dockerfile into as many stages as possible, because this will allow for better caching
* `apt-get`:
	* You must run `apt-get update` and `apt-get install` in the same command, otherwise you will encounter caching issues
	* Remember to use `apt-get install -y`, because you will have no control over the process while it's building
* Useful resources:
	* [Dockerfile reference](https://docs.docker.com/engine/reference/builder/)
	* [Best practices](https://docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices/)
---
# Docker Build
* To build a Docker image from a Dockerfile, use the `docker build` command
* You should specify an image tag/name using `-t`, and a directory containing the Dockerfile. For example:
```bash
docker build -t my_image .
```
---
# Exercise - Dockerizing Samtools
* Samtools is a common utility for working with SAM and BAM alignment files
* Samtools can be installed using `apt-get install samtools`

.message.is-info[
.message-header[
Exercise
]
.message-body[
* Create a Dockerfile for samtools inside its own directory, and build it using `docker build`
* Make sure you tag it as `my_samtools`, we'll need it later on
* You'll also need to set the entrypoint to the `samtools` command
* Once it's finished, try testing it using the SAM file provided:

```bash
docker run -i my_samtools view -H - < data/alignment.sam
```
]
]

---
# Exercise - Dockerizing Samtools
.message.is-success[
.message-header[
Solution
]
.message-body[
`my_samtools/Dockerfile`:
```
FROM ubuntu
RUN apt-get update && apt-get install -y samtools
ENTRYPOINT ["samtools"]
```
Building:
```bash
docker build -t my_samtools my_samtools/
```
]
]

---
# Exercise - Dockerizing BWA
* bwa can be installed in much the same way as samtools

.message.is-info[
.message-header[
Exercise
]
.message-body[
* Try making a Dockerfile for `bwa`
* Make sure you tag this as `my_bwa`
* The image is probably working if it prints out the `bwa` help when you run the image
]
]

--

.message.is-success[
.message-header[
Exercise
]
.message-body[
`my_bwa/Dockerfile`:
```
FROM ubuntu
RUN apt-get update && apt-get install -y bwa
ENTRYPOINT ["bwa"]
```

Building:
```bash
docker build -t my_bwa my_bwa/
```
]
]
---
# Exercise - Dockerizing Freebayes
* Freebayes is an open-source variant caller (calculates how a given individual's DNA differs from a reference genome)
* Freebayes is a little harder to install - you'll need to build it from source
* Installation instructions for Freebayes can be found here: https://github.com/ekg/freebayes#obtaining

.message.is-info[
.message-header[
Exercise
]
.message-body[
* Try making a Dockerfile for `freebayes`
* As a tip, the apt-get repositories you need for this will be: `git build-essential zlib1g-dev libbz2-dev liblzma-dev`
* Make sure you tag this as `my_freebayes`
]
]

---
# Exercise - Dockerizing Freebayes
.message.is-success[
.message-header[
Solution
]
.message-body[
`my_bwa/freebayes`:
```
FROM ubuntu
RUN apt-get update && apt-get install -y git build-essential zlib1g-dev libbz2-dev liblzma-dev
WORKDIR /tmp
RUN git clone --recursive git://github.com/ekg/freebayes.git
WORKDIR freebayes
RUN make
RUN make install
ENTRYPOINT ["freebayes"]
```

Building:
```bash
docker build -t my_freebayes my_freebayes/
```
]
]

---
# Dockerized Pipelines
* Docker containers are often used to provide the tools and runtime environment for each stage in a bioinformatics pipeline
* A number of workflow frameworks support Docker:
	* Broad's WDL
	* CWL (Common Workflow Language)
	* Galaxy

![](assets/Docker Workflows.svg)

---
# Dockerized Pipelines
Conveniently, the images you just make are just the right ones for running a variant calling pipeline
.message.is-info[
.message-header[
Exercise
]
.message-body[
Try running
```bash
cwltool cwl_workflow/workflow.cwl \
	--read_1 data/NA12878_CARDIACM_MUTATED_L001_R1.fastq.gz \
	--read_2 data/NA12878_CARDIACM_MUTATED_L001_R2.fastq.gz \
	--reference data/ucsc.hg19.fasta
```
]
]

And while that's running, we'll move onto the next topic...
---
class: center, middle
# Part 4
## Docker on HPC
---
# Docker on HPC
* Security on HPC:
	* If you have Docker access, you effectively have `root` permissions over the entire operating system
	* This works fine on the cloud, where instances are rarely shared between multiple users
	* However on HPC (computing clusters etc), this would allow Docker users to access each other's files
	* For this reason, it is unlikely you will find Docker installed on an HPC system
* A few alternatives exist for running containers on HPC, but there's only one that really matters
	* [Singularity](http://singularity.lbl.gov/) - A ground-up reimplementation of Docker, with a fairly different CLI. Actively developed.

.columns.is-centered[
.column.is-narrow[
.image.is-128x128[
![](assets/singularity.png)
]
]
]
---
# Converting a Docker Image
* Unlike Docker, Singularity stores its images as individual files
* You can convert a docker image to a singularity image using Singularity:
```bash
singularity build [IMAGE NAME].sif docker-daemon://[IMAGE NAME]:latest
```

.message.is-info[
.message-header[
Exercise
]
.message-body[
Using the command above, try creating a singularity image from your `my_samtools` image
]
]

---
# Running a Singularity Image
.message.is-info[
.message-header[
Exercise
]
.message-body[
Test out that your singularity image works properly using:
```bash
singularity run [IMAGE FILE] view -H < data/alignment.sam
```
]
]
---
class: left, middle
# Summary and Closing

After the workshop, participants should know:
* What containerisation is and why they might use it in their research.
* Some common containerisation tools and when to use them.
* How to find and run containers built by other people.
* How to build their own container.
* How to distribute their container online.
---
class: center, middle
# That's All
